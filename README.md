AppStudio - Hangman
=========

AppStudio minor programmeren 2013-2014 course


Description
========









Immediately upon launch, gameplay must start (unless the app was simply backgrounded, in which case gameplay, if in progress prior to backgrounding, should resume).

Your app’s front side must display placeholders (e.g., hyphens) for yet-unguessed letters that make clear the word’s length.

Your app must inform the user (either numerically or graphically) how many incorrect guesses he or she can still make before losing.

Your app must somehow indicate to the user which letters he or she has (or, if you prefer, hasn’t) guessed yet.

The user must be able to input guesses via an on-screen keyboard.

Your app must only accept as valid input single alphabetical characters (case-insensitively).

Invalid input (e.g., multiple characters, no characters, characters already inputted, punctuation, etc.) should be ignored (silently or with some sort of alert) but not penalized.

Your app must have a title (e.g., Hangman) or logo and one button that starts a new game.

If the user guesses every letter in some word before running out of chances, he or she should be somehow congratulated, and gameplay should end (i.e., the game should ignore any subsequent keyboard input). If the user fails to guess every letter in some word before running out of chances, he or she should be somehow consoled, and gameplay should end. The front side’s two buttons should continue to operate.

A user must be able to configure two settings: the length of words to be guessed (the allowed range for which must be [1,n], where n is the length of the longest word in words.plist/xml); and the maximum number of incorrect guesses allowed (the allowed range for which must be [1,26]).

Your app must maintain a history of high scores that’s displayed anytime a game is won or lost. We leave the definition of “high scores” to you, but you should somehow rank the results of at least 10 games (assuming at least 10 games have been won), displaying for each the word guessed and the number of mistakes made (which is presumably low). The history of high scores should persist even when your app is backgrounded or force-quit.













The app will provide a platform where riddle-puzzles can be solved and created.
A leaderboard keeps track of each players ranking, each user can see the guesses they made on puzzles in the past.
Puzzles consist of four pictures and several letters, the answer is an arrangment of some of the given letters.
The pictures 

    The app’s UI will be designed for a smartphone whose width is defined by device-width; its actual resolution might be anywhere from 320×480 to 760×1280.

    The app will enable users to register, create a personal profile and log in.

    The app will enable users to solve puzzles.
    
    The app will enable users to view their previous attemps on puzzles.
    
    The app will reward correctly solved puzzles with scores and medals for special achievements. (For instance 5 correct in a row.)

    The app will enable users to compare their score to other players.

    The app will enable users to add puzzles.
    
    The app will display a difficulty score based on the amount of people who succesfully solved it.
    
    The app will enable users to watch each others profile and play the puzzles generated by this specific user.

Technical specifications

    The app will be implemented with HTML5, JavaScript, and Ruby.

    The app will use jQuery Mobile (and jQuery) for its client-side framework.

    The app will use Ruby on Rails for its server-side framework.

    The app may use third-party libraries and plugins (for CSS, JavaScript, and/or Ruby) in addition to, but not instead of, jQuery Mobile and Rails, so long as their sources are cited, as with comments, in the README.

    The app will adhere to an MVC architecture (as it should by nature of Ruby on Rails).

    The HTML5 will be well-formed but it need not be considered valid by the W3C’s validator (which dislikes browser-specific tags).

    The app will store users’ lists server-side in a SQLite database or client-side in a SQLite database or in HTML5 localStorage.

    The app requires a log in.
